<!DOCTYPE html>
<html lang="zh">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  
  <link rel="prev" href="https://air.googol.im/post/what-i-want-in-go2-type-system/" />
  
  <link rel="canonical" href="https://air.googol.im/post/rust-view-from-a-gopher/" />
  <link rel='shortcut icon' type='image/x-icon' href='/favicon.ico' />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           一个Go开发者的Rust体验 | Air on G
       
  </title>
  <meta name="title" content="一个Go开发者的Rust体验 | Air on G">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一个Go开发者的Rust体验"/>
<meta name="twitter:description" content="一直很关注Rust这门语言的发展，不过没有实际使用过。最近Rust准备以2018 Rust的名义发布可以用作生产环境的稳定版本，又赶上有兴趣写点东西，所以把一个基础模块同时用Rust和Go实现了一下。本文就是这次实现的一些结果。
我自己有很长的Go使用经历，所以本文对Go的看法会相对比较准确。Rust虽然关注了很长时间，但代码基本上是最近一个星期左右的成果，可能看法有偏颇。"/>

  <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "一个Go开发者的Rust体验",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https:\/\/air.googol.im\/post\/rust-view-from-a-gopher\/"
  },
  "image": {
    "@type": "ImageObject",
    "url": "https:\/\/air.googol.im\/cover.png",
    "width":  800 ,
    "height":  600 
  },
  "genre": "post",
  "keywords": "rust, go",
  "wordcount":  5554 ,
  "url": "https:\/\/air.googol.im\/post\/rust-view-from-a-gopher\/",
  "datePublished": "2018-07-21T11:10:00\u002b02:00",
  "dateModified": "2018-07-21T11:10:00\u002b02:00",
  "license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.",
  "publisher": {
    "@type": "Organization",
    "name": "Googol Lee",
    "logo": {
      "@type": "ImageObject",
      "url": "https:\/\/air.googol.im\/logo.png",
      "width":  127 ,
      "height":  40 
    }
  },
  "author": {
    "@type": "Person",
    "name": "Googol Lee"
  },
  "description": ""
}
</script>
</head>

  



  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="https://air.googol.im">Air on G</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about" title="">About</a>
                
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-sun"></i></a>&nbsp;
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-sun"></i></a>&nbsp;<a href="https://air.googol.im">Air on G</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about" title="">About</a>
                
        </div>
    </div>
</nav>

    	 <main class="main">
          <div class="container">
      		
<article class="post-warp">
    <header class="post-header">
        <h1 class="post-title">一个Go开发者的Rust体验</h1>
        <div class="post-meta">
              <a href="https://air.googol.im" rel="author">Googol Lee</a>  ♥ 
                <span class="post-time">
                     <time datetime=2018-07-21 >2018-07-21</time>
                </span>
                
                
                <i class="iconfont icon-timer"></i>
                12 min
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <p>一直很关注Rust这门语言的发展，不过没有实际使用过。最近Rust准备以2018 Rust的名义发布可以用作生产环境的稳定版本，又赶上有兴趣写点东西，所以把一个基础模块同时用Rust和Go实现了一下。本文就是这次实现的一些结果。</p>
<p>我自己有很长的Go使用经历，所以本文对Go的看法会相对比较准确。Rust虽然关注了很长时间，但代码基本上是最近一个星期左右的成果，可能看法有偏颇。</p>
<p>这次对比的内容是实现一个针对短字符串优化的字符串。在反序列化时，由于字符串长度未知，导致反序列化时需要根据接收到的字符串创建一段内存来容纳内容。不过一般情况下，反序列化时的字符串长度都较小，由此导致反复申请释放内存，会消耗很多性能。短字符串的优化是，针对某个长度的字符串，提前分配好内存，如果反序列化的长度不足这个长度，直接使用分配好的内存存储内容，不再申请内存，也就没有了释放过程，从而提高效率。</p>
<p>由于我对Go更加熟悉，所以首先使用Go实现了这个功能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">prealloc_size</span> = <span style="color:#ae81ff">20</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">String</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">data</span> [<span style="color:#a6e22e">prealloc_size</span>]<span style="color:#66d9ef">byte</span>
  <span style="color:#a6e22e">buf</span>  []<span style="color:#66d9ef">byte</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">String</span>) <span style="color:#a6e22e">fill</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">uint</span>) <span style="color:#66d9ef">error</span> {
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#a6e22e">prealloc_size</span> {
    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">buf</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span>)
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">data</span>[:<span style="color:#a6e22e">n</span>]
  }
  <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ReadFull</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">buf</span>)
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">String</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">buf</span>))
}
</code></pre></div><p>这段代码相当直白，不做过多介绍。唯一值得一提的是<code>String.String()</code>方法，利用<code>unsafe</code>来将<code>buf</code>直接当做字符串，避免再次分配内存。具体可以参考官方库的<code>strings.Builder.String()</code>方法。</p>
<p>既然要测试性能，必然要有相关的性能测试代码。为了简洁，这里就不展示单元测试的内容了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> (
	<span style="color:#a6e22e">shortStr</span> = <span style="color:#e6db74">&#34;short str&#34;</span>
	<span style="color:#a6e22e">longStr</span>  = <span style="color:#e6db74">&#34;loooooooooonnnnnnnnnngggggggg string&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkShortString</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">StopTimer</span>()
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#a6e22e">String</span>
	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">shortStr</span>)
	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">data</span>)
	<span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> uint(len(<span style="color:#a6e22e">data</span>))
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">StartTimer</span>()

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Reset</span>(<span style="color:#a6e22e">data</span>)
		<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">fill</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">l</span>)
		<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">String</span>()
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkLongString</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">StopTimer</span>()
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#a6e22e">String</span>
	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">longStr</span>)
	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">data</span>)
	<span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> uint(len(<span style="color:#a6e22e">data</span>))
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">StartTimer</span>()

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Reset</span>(<span style="color:#a6e22e">data</span>)
		<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">fill</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">l</span>)
		<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">String</span>()
	}
}
</code></pre></div><p>测试结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ go test -bench . -benchmem
goos: darwin
goarch: amd64
pkg: github.com/googollee/rtnx/rtmp/amf
BenchmarkShortString-4    	50000000	        25.1 ns/op	       <span style="color:#ae81ff">0</span> B/op	       <span style="color:#ae81ff">0</span> allocs/op
BenchmarkLongString-4     	20000000	        67.0 ns/op	      <span style="color:#ae81ff">48</span> B/op	       <span style="color:#ae81ff">1</span> allocs/op
PASS
ok  	github.com/googollee/rtnx/rtmp/amf	3.189s
</code></pre></div><p>可以看到，短字符串在测试中确实没有再次分配内存，并且相比长字符串，性能有了显著提高。</p>
<p>之后，先是对这段代码直接翻译为Rust。但在翻译过程中遇到了不少问题。</p>
<p>首先遇到的问题，当然是所有权的问题！Go结构里的<code>buf</code>实际有两种引用：要么引用内部<code>data</code>的一段内存，要么引用一段分配的内存。而Rust，基本上没办法让一个struct在内部互相引用。Rust强制所有引用必须以树状组织所有权，而内部引用这种情况，相当于一个节点内引用自己，没办法形成树状所有权。所以需要将这个域拆成两个，一个表示在引用<code>data</code>时，需要引用多长的地址，另一个表示如果有必要，引用到一段分配的内存。第一次尝试如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> String {
    data: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">20</span>],
    heap: Option<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span>[<span style="color:#66d9ef">u8</span>]<span style="color:#f92672">&gt;&gt;</span>,
    len: <span style="color:#66d9ef">usize</span>,
}
</code></pre></div><blockquote>
<p>本来是想利用Rust的模版，将预先分配的内存长度参数化。结果试了很久，发现Rust还不支持常数模版，所以这里20的长度直接硬编码。好在后面的实现不会直接依赖20这个数，所以没有做进一步改动。</p>
<p>Rust社区使用类似<code>String&lt;[u8; 20]&gt;</code>的方式来实现常数模版参数。这是一个workaround。目前Rust官方已经有常数模版的<a href="https://github.com/rust-lang/rust/issues/44580">提案</a>。</p>
</blockquote>
<p>其中<code>data</code>和之前一样，是预先分配的一段内存。<code>len</code>用来记录，在短字符串的情况下，使用了多长的<code>data</code>的内容。由于去掉了引用关系，所以不会违反Rust的所有权。</p>
<p>但下一个问题，<code>heap</code>应该如何定义？Rust规定，所有的引用都必须指向相应的引用对象，不能出现没有引用的引用变量，因此<code>&amp; T</code>是不能为空的。而我希望<code>heap</code>在正常情况下需要为空。因此这里使用<code>Option&lt;_&gt;</code>来表示一个要么为<code>None</code>，要么有值的类型。</p>
<p>接下来的<code>Box&lt;_&gt;</code>表示持有一个在堆上分配的类型。与Go不同，Rust非常明确的区分堆变量和栈变量，而Go通过编译器的逃逸分析，会自己决定一个变量是否需要放到堆上并在之后由GC回收。这体现了两种语言完全不同的思路：Go试图降低程序员需要了解的实现细节，提供尽量少但足够的基础设施，保证上手容易的同时保证性能；而Rust则暴露了大量的细节给程序员，并强迫程序员遵守约束，并使用这些约束保证程序正确。由于Rust暴露了实现细节，有经验的用户可以根据这些细节做更激进的优化。而Go很多时候受限编译器的能力无法实现（很多时候是不知道可以进行）这类优化。比如Go在读取链接时常会开一段临时内存进行存储：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Handle</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">data</span> [<span style="color:#ae81ff">20</span>]<span style="color:#66d9ef">byte</span>
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">data</span>[:])
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>其中<code>data</code>就是临时分配的内存。理论上，这段内存如果只在<code>Handle</code>中使用，只在栈上就可以，随着<code>Handle</code>退出自动释放。但是由于逃逸分析无法获知是否在<code>r.Read()</code>时持有了<code>data[:]</code>这个引用，这里会认为<code>data</code>有逃逸，所以会将其分配在堆上，并导致后面gc的参与。</p>
<p>回到Rust，最终，<code>heap</code>被定义为<code>Option&lt;Box&lt;[u8]&gt;&gt;</code>，表示一个可以为<code>None</code>，也可以是一个分配在堆上的<code>[u8]</code>。<code>[u8]</code>这个类型与Go的slice从概念到实现都很类似，是对数组的一种引用。值得注意的是，<code>[u8]</code>由于无法在编译时预知引用的长度，所以无法直接在栈上创建一个<code>[u8]</code>的变量。</p>
<p>接下来是<code>fill()</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fill</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, r: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">impl</span> io::Read, n: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&gt;</span> self.data.len() {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> Vec::with_capacity(n);
        <span style="color:#66d9ef">unsafe</span> { v.set_len(n) };
        self.heap <span style="color:#f92672">=</span> Some(v.into_boxed_slice());
        <span style="color:#66d9ef">match</span> self.heap.as_mut() {
            Some(b) <span style="color:#f92672">=&gt;</span> b,
            None <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;should not here&#34;</span>),
        }
    } <span style="color:#66d9ef">else</span> {
        self.len <span style="color:#f92672">=</span> n;
        <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.data[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>n]
    };

    <span style="color:#66d9ef">return</span> read_full(r, buf);
}
</code></pre></div><p>Rust默认保证变量使用时必须做过初始化，而这里<code>Vec::with_capacity()</code>分配内存后，并不需要确定数据的内容，随后会填入具体数据，所以使用<code>unsafe { v.set_len(n) }</code>来强制使用该段未初始化的内存。值得注意的是，当使用<code>v.into_boxed_slice()</code>将这段内存的所有权交给<code>self.heap</code>后，需要有一种方法再取回这段内存的引用，并赋给<code>buf</code>变量。<code>self.heap</code>的类型是<code>Option&lt;Box&lt;[u8]&gt;&gt;</code>，按照习惯，需要按照<code>Option&lt;Box&lt;[u8]&gt;&gt; -&gt; Box&lt;[u8]&gt; -&gt; [u8] -&gt; &amp;mut [u8]</code>的顺序取得引用。但是这里有个问题，如果变成了<code>Box&lt;[u8]&gt;</code>，证明这是一个自己拥有生命周期的变量类型，而不是一个引用。所以这里的取引用的顺序是<code>Option&lt;Box&lt;[u8]&gt;&gt; -&gt; Option&lt;&amp;mut Box&lt;[u8]&gt;&gt; -&gt; &amp;mut Box&lt;[u8]&gt; -&gt; &amp;mut [u8]</code>。而第一步就是通过<code>self.heap.as_mut()</code>来取得引用。</p>
<p><!-- raw HTML omitted -->由于Rust没有官方的<code>io.ReadFull()</code>，所以这里做了自己的实现：<!-- raw HTML omitted -->经<a href="https://twitter.com/upsuper">@upsuper</a>提醒，Rust官方有类似的实现<code>std::io::Read::read_exact</code>。不过这里依旧使用自己的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_full</span>(r: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">impl</span> io::Read, b: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [<span style="color:#66d9ef">u8</span>]) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> b.len() {
        <span style="color:#66d9ef">match</span> r.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> b[i<span style="color:#f92672">..</span>]) {
            Err(b) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(b),
            Ok(n) <span style="color:#f92672">=&gt;</span> {
                i <span style="color:#f92672">+=</span> n;
            }
        }
    }
    Ok(())
}
</code></pre></div><p><code>io::Result&lt;()&gt;</code>是很展现Rust特色的类型。这个类型是表示一个要么是<code>()</code>的类型值，要么是<code>io::Error&lt;_&gt;</code>的类型值。<code>()</code>类型是Rust里的某种元类型，某种程度上可以看作是<code>nil</code>类型或者表示不需要关心的返回值。<code>io::Error&lt;_&gt;</code>就很简单，是表示某种io的错误，具体错误类型由模版类型<code>_</code>决定。对比Go的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadFull</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>)
</code></pre></div><p>显然，Go的类型无法在语法上保证<code>ReadFull()</code>同时返回<code>int</code>和<code>error</code>。而同时返回两个值会造成调用者困惑：到底这是个正常返回，还是个错误？不要以为Go里常用<code>error</code>后置的约定，就不会出现这种情况。实际上Go标准库都无法防止这种情况<a href="https://godoc.org/io#Reader">出现</a>：</p>
<blockquote>
<p>When Read encounters an error or end-of-file condition after successfully reading n &gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</p>
</blockquote>
<p>而对这种类型错误的处理，简单处理可以直接<code>unwrap()</code>（后面会有展示），这里使用<code>match</code>是更精细的处理。由于<code>match</code>是个表达式而不是语句，所以可以使用下面的方法处理错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> ret <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> function() {
  Err(err) <span style="color:#f92672">=&gt;</span> {
    <span style="color:#75715e">// handle err
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> Err(err);
  },
  Ok(r) <span style="color:#f92672">=&gt;</span> r,
}
</code></pre></div><p>与Go的错误处理对比：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">function</span>()
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
  <span style="color:#75715e">// handle err
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
}
</code></pre></div><p>Rust错误处理的优点是不会出现<code>err</code>变量四处定义的现象，不过Go代码量更少。不过，借助Rust的宏，如果不需要特别处理返回错误err，而是直接返回的话，Rust可以简写为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> ret <span style="color:#f92672">=</span> function()<span style="color:#f92672">?</span>
</code></pre></div><p>这就显得比Go好看多了。即便是预期中<a href="https://github.com/gopherchina/conference/blob/3a0f94003da58e09c5acfa926a604643f6846491/2018/3.%20Rethinking%20Errors%20for%20Go%202.pdf">Go2的错误处理</a>都并不比这个好。</p>
<p>接下来是性能测试部分。我不知道Rust对于<em>工程</em>这件事情是怎么理解的，反正在我实验时，Cargo项目在stable分支支持<code>bench</code>命令，但却依赖nightly的一个testing包才能用。目前的Rust项目里充满了这种奇怪的，号称stable提供但却依赖nightly的特性，导致构建完整工程时十分痛苦。与Go自带非常稳定的<code>testing.B</code>特性相比，Rust这方面感觉一点都不像一个有着合理规划的号称稳定版三年之久的项目。</p>
<p>最终，使用<a href="https://github.com/japaric/criterion.rs">Criterion</a>项目完成整个性能测试，代价是性能测试代码与<code>String</code>定义代码分在不同目录，且没办法引用<code>String</code>类型的私有方法。这也是上面将<code>fill()</code>定义为<code>pub</code>的原因。测试代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[macro_use]</span>
<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> criterion;
<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> rtnx;

<span style="color:#66d9ef">use</span> criterion::Criterion;
<span style="color:#66d9ef">use</span> rtnx::rtmp::<span style="color:#f92672">*</span>;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">string</span>(c: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Criterion) {
    c.bench_function(<span style="color:#e6db74">&#34;short str&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> String::new();
        <span style="color:#66d9ef">let</span> data: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;short str&#34;</span>;

        b.iter(<span style="color:#f92672">||</span> {
            <span style="color:#66d9ef">str</span>.fill(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> data.as_bytes(), data.len()).unwrap();
            <span style="color:#66d9ef">str</span>.string();
        })
    });

    c.bench_function(<span style="color:#e6db74">&#34;long str&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> String::new();
        <span style="color:#66d9ef">let</span> data: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;loooooooooooooooooonnnnnnnnnnnnng str&#34;</span>;

        b.iter(<span style="color:#f92672">||</span> {
            <span style="color:#66d9ef">str</span>.fill(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> data.as_bytes(), data.len()).unwrap();
            <span style="color:#66d9ef">str</span>.string();
        })
    });
}
</code></pre></div><p>Rust本身为<code>&amp;[u8]</code>类型实现了<code>Read</code>，所以可以直接将<code>data.as_bytes()</code>作为一个<code>Read</code>使用。由于<code>fill()</code>需求的是<code>&amp;mut Read</code>，这里会使用<code>&amp;mut data.as_bytes()</code>。而<code>'static</code>表示静态生命周期，也就是常量字符串。</p>
<p>测试结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ cargo bench
    Finished release <span style="color:#f92672">[</span>optimized<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 0.27s
     Running target/release/deps/rtnx-b3fb2c92c52ff0ff

running <span style="color:#ae81ff">1</span> test
test rtmp::amf::string_test::test_string ... ignored

test result: ok. <span style="color:#ae81ff">0</span> passed; <span style="color:#ae81ff">0</span> failed; <span style="color:#ae81ff">1</span> ignored; <span style="color:#ae81ff">0</span> measured; <span style="color:#ae81ff">0</span> filtered out

     Running target/release/deps/rtnx-b073d7725e43e2cb

running <span style="color:#ae81ff">1</span> test
test rtmp::amf::string_test::test_string ... ignored

test result: ok. <span style="color:#ae81ff">0</span> passed; <span style="color:#ae81ff">0</span> failed; <span style="color:#ae81ff">1</span> ignored; <span style="color:#ae81ff">0</span> measured; <span style="color:#ae81ff">0</span> filtered out

     Running target/release/deps/string-e1abdea77166d91b
Gnuplot not found, disabling plotting
short str               time:   <span style="color:#f92672">[</span>8.8030 ns 8.8762 ns 8.9604 ns<span style="color:#f92672">]</span>                       
                        change: <span style="color:#f92672">[</span>-2.0804% +0.0430% +1.9924%<span style="color:#f92672">]</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> 0.96 &gt; 0.05<span style="color:#f92672">)</span>
                        No change in performance detected.
Found <span style="color:#ae81ff">12</span> outliers among <span style="color:#ae81ff">100</span> measurements <span style="color:#f92672">(</span>12.00%<span style="color:#f92672">)</span>
  <span style="color:#ae81ff">8</span> <span style="color:#f92672">(</span>8.00%<span style="color:#f92672">)</span> high mild
  <span style="color:#ae81ff">4</span> <span style="color:#f92672">(</span>4.00%<span style="color:#f92672">)</span> high severe

long str                time:   <span style="color:#f92672">[</span>29.893 ns 30.005 ns 30.156 ns<span style="color:#f92672">]</span>                      
                        change: <span style="color:#f92672">[</span>-0.1391% +0.6297% +1.4001%<span style="color:#f92672">]</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> 0.12 &gt; 0.05<span style="color:#f92672">)</span>
                        No change in performance detected.
Found <span style="color:#ae81ff">6</span> outliers among <span style="color:#ae81ff">100</span> measurements <span style="color:#f92672">(</span>6.00%<span style="color:#f92672">)</span>
  <span style="color:#ae81ff">3</span> <span style="color:#f92672">(</span>3.00%<span style="color:#f92672">)</span> high mild
  <span style="color:#ae81ff">3</span> <span style="color:#f92672">(</span>3.00%<span style="color:#f92672">)</span> high severe

Gnuplot not found, disabling plotting
</code></pre></div><p>与之前Go的测试结果对比：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>短字符串</th>
<th>长字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rust</td>
<td>8.8762ns</td>
<td>30.005ns</td>
</tr>
<tr>
<td>Go</td>
<td>25.1ns</td>
<td>67.0ns</td>
</tr>
</tbody>
</table>
<p>Rust在两种情况都只用了Go不到一半的时间。Rust在性能方面确实完胜Go。</p>
<p>一些上面没有提到的事情。</p>
<p>首先是并发。Go自带并发，可以简单使用<code>go/chan</code>来做到高效且资源消耗小的并发。Rust语言层面没有这个支持，但是凭借灵活的类型系统，通过Future类型为并发提供了基础设施。在此之上，<a href="https://tokio.rs/">tokio</a>实现了类似goroutine的一套并发机制。由于Go的类型系统过于简单，是没办法以库的方式实现并发的。这一点，Rust做的非常漂亮。</p>
<p>关于包，与Go基于目录的package相比，Rust就充满了没有必要的复杂性。Rust里通过<code>mod name</code>可以引入另一个编译单元name，这个单元可以是同目录下的文件<code>name.rs</code>，也可以是子目录下的文件<code>name/mod.rs</code>。而<code>mod</code>本身还会生成一个<code>name</code>的命名空间，如果要引用包里的符号，要么通过<code>use</code>引入符号，要么带着<code>name::</code>作为符号前缀给出命名空间。这导致想将一个包里的代码分到不同文件时，变得异常复杂。基本上，想要做到拆分文件又能互相引用，需要写类似下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">mod</span> part1;
<span style="color:#66d9ef">mod</span> part2;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">use</span> self::part1::<span style="color:#f92672">*</span>;
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">use</span> self::part2::<span style="color:#f92672">*</span>;
</code></pre></div><p>而这还会导致<code>part1</code>和<code>part2</code>里的私有符号互相不可见。<code>mod/use</code>这一特性看似灵活，实际最终会强制一个包的内容全部写到一个文件里。与Go自然的“一个包一个目录”的形式相比，理解和使用都会困难很多。而Rust 2018也试图改进这个问题，细节可以查看<a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/modules/path-clarity.html">Path clarity</a>。</p>
<p>Rust对编译单元的控制，是依靠宏指令来完成的。比如如果说一部分代码只在测试时编译，就需要写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[cfg(test)]</span>
<span style="color:#66d9ef">mod</span> tests {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这样<code>mod tests</code>内部的代码就只会在<code>test</code>时才做编译。而Go使用文件后缀来做这种区分。比如<code>xxx_test.go</code>默认只在测试是编译。这里我认为Go的方式更自然。一个包里有哪些编译控制，哪个文件会在哪个状态用到，直接看文件名就能知道。类似<code>xxx_unix.go/yyy_windows.go</code>也为维护提供了方便。Rust如果没有合适的工具的话，就只能一个一个文件查看，才能知道编译规则。</p>
<p>说道工具，Rust工具链的质量和Go相比，可以用惨不忍睹来形容。上文提到的性能测试就是一例。Rust大量工具目前处于preview或者只提供nightly的地步（好像最近clippy刚刚进入到stable的preview状态）。Rust社区希望2018能够提供一个稳定生产力的版本<a href="https://rust-lang-nursery.github.io/edition-guide/2018/index.html">Rust 2018</a>，不过现在2018都已经过半，还有一部分语法工作没有合并到stable。<!-- raw HTML omitted -->这不得不想起当年C++ 98拖到C++ 00再拖到C++ 0x。希望Rust能在发布语言版本的时候，考虑一部分核心工具链的同时发布。<!-- raw HTML omitted -->Rust社区将2018版本的发布时间定在10月，目前各个项目与预期进度相符。希望在今年底能看到更具生产力的稳定版本，不仅仅是语言的特性，还包括关键工具链。</p>
<p>至于工程项目，cargo做的很好。Go目前的<code>GOPATH</code>模式，大概只有Google自己觉得好。好在Go modules已经<a href="https://groups.google.com/forum/#!topic/golang-dev/a5PqQuBljF4">箭在弦上</a>，马上就不用忍受这么难用的功能了。</p>
<p>最后的总结。</p>
<p>Rust和Go是完完全全两个思路下的语言。Go会尽力优化开发流程，减少暴露给程序员的概念，并有足够稳定的接口。而Rust则将所有特性暴露给程序员做选择，语言社区只负责核心编译器，将最佳实践固化为语言特性，工具链交由社区进行完善。</p>
<p>我建议所有的Go程序员去尝试一下Rust，体会一下编译器如何强制要求理解程序的细节。这些细节是Go试图隐藏的复杂性，但是理解这些细节对编写程序，哪怕是Go程序，都是很有帮助的。另一方面，对于公司，如果是为了建立一个“铁打的营盘”，组建一个不同技能等级的团队，充分利用已有的社区力量，简化工程复杂性的话，Go是目前更好的选择。</p>
    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>:</span>
                <span>Googol Lee </span>
                </p>
            
           
            <p class="copyright-item">
                    <span>:</span>
                   <span>5554</span>
            </p>

            <p class="copyright-item">
                
                <span>:</span>
                <span>

      
        <a href="//twitter.com/share?url=https%3a%2f%2fair.googol.im%2fpost%2frust-view-from-a-gopher%2f&amp;text=%e4%b8%80%e4%b8%aaGo%e5%bc%80%e5%8f%91%e8%80%85%e7%9a%84Rust%e4%bd%93%e9%aa%8c&amp;via=googollee" target="_blank" title="Share on Twitter">
          <i class="iconfont icon-twitter"></i>
        </a>
        
      
      
      
      
      
      
      
      
        
      
        
      

          

          

          

          

</span>
                
            </p>

             
            <p class="copyright-item">
                Released under <a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-icon-tag"></i>: 
            
            <span class="tag"><a href="https://air.googol.im/tags/rust/">
                    #rust</a></span>
            
            <span class="tag"><a href="https://air.googol.im/tags/go/">
                    #go</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();"></a></span> · 
                <span><a href="https://air.googol.im"></a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://air.googol.im/post/what-i-want-in-go2-type-system/" class="prev" rel="prev" title="我对Go 2类型系统的期望"><i class="iconfont icon-dajiantou"></i>&nbsp;我对Go 2类型系统的期望</a>
         
        
    </div>

    <div class="post-comment">
          
          <div id="disqus_thread"></div>
  <script type="text/javascript">
      (function() {
          
          
          if (window.location.hostname == "localhost")
              return;
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          var disqus_shortname = 'air-g';
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

 

          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2004 - 2021</span>
        
         
            <span class="author" itemprop="copyrightHolder"><a href="https://air.googol.im">Googol Lee</a> | </span>
         

		  <span>Crafted with ❤️ by <a href="https://github.com/Fastbyte01/KeepIt" target="_blank" rel="external nofollow noopener noreffer">KeepIt</a> & <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a></span>
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  







     </div>
  </body>
</html>
