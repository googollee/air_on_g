<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interview on Air on G</title>
    <link>http://air.googol.im/tags/interview/</link>
    <description>Recent content in Interview on Air on G</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>除非另有声明，本网站采用&lt;a href=&#39;https://creativecommons.org/licenses/by-nd/3.0/cn/&#39;&gt;知识共享“署名-禁止演绎 3.0 中国大陆”许可协议&lt;/a&gt;授权。</copyright>
    <lastBuildDate>Thu, 26 Oct 2006 20:00:00 +0800</lastBuildDate>
    <atom:link href="http://air.googol.im/tags/interview/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>终于知道当初微软的面试题，我错在哪里了……</title>
      <link>http://air.googol.im/post/question-in-face-interview-of-microsoft/</link>
      <pubDate>Thu, 26 Oct 2006 20:00:00 +0800</pubDate>
      
      <guid>http://air.googol.im/post/question-in-face-interview-of-microsoft/</guid>
      <description>&lt;p&gt;有两杯液体，一杯蓝色一杯红色，两杯液体的体积一样。从红色液体中取出一试管液体，倒入蓝色液体中，搅匀。再从原来蓝色（现在是混合的）液体中取出同样一试管的液体，倒入红色中，搅匀。问最后两个杯子中，哪个杯子里的杂质更多。&lt;/p&gt;

&lt;p&gt;嗯……给出当时我的思路吧：&lt;/p&gt;

&lt;p&gt;从红的中取出一试管，倒入蓝的中，搅匀。这时候蓝色溶液里杂质的浓度为a。然后再从这杯杂质浓度为a的液体中取出一试管，倒入红的里。由于红的之前是纯净的，倒入杂质浓度为a的液体后，相当于对这个液体做稀释，因此现在红色这杯子里的杂质浓度小于a。又因为这个时候两杯子里液体体积还是一样的，因此杂质浓度高的杯子里杂质更多，也就是蓝色液体的杯子。&lt;/p&gt;

&lt;p&gt;但是，从另一个角度想想，最终两杯子里液体的体积是一样的，如果两杯子里杂质的密度不一致，比如蓝色的里面杂质多，那么，可以推出，红色的液体的总量会多于蓝色液体。这就与初始时“两个杯子液体体积一样”是矛盾的。&lt;/p&gt;

&lt;p&gt;所以，我的推理一定错了。不管怎么倒，最终结果，两个杯子的杂质一定一样多！&lt;/p&gt;

&lt;p&gt;数学是最严谨的。先用数学算一遍吧。假设两个液体最初的体积是L，试管的体积是l，那么第一次倒后，蓝色液体里含有&lt;code&gt;l&lt;/code&gt;积的红色液体，搅匀后，蓝色杯子中总体积为&lt;code&gt;(L+l)&lt;/code&gt;，从这个杯子里舀出l体积的一试管液体中，含有红色液体&lt;code&gt;l*l/(L+l)&lt;/code&gt;，含有蓝色液体&lt;code&gt;l*L/(L+l)&lt;/code&gt;。蓝色杯子里还剩下&lt;code&gt;L*l/(L+l)&lt;/code&gt;体积的红色液体和&lt;code&gt;L*L/(L+l)&lt;/code&gt;的蓝色液体。将试管里的混合液倒入&lt;code&gt;(L-l)&lt;/code&gt;体积的红色液体后，蓝色液体体积是&lt;code&gt;l*L/(L+l)&lt;/code&gt;，红色液体是&lt;code&gt;(L-l)+l*l/(L+l)&lt;/code&gt;。由于蓝色杯子中，杂质红色液体的体积&lt;code&gt;L*l/(L+l)&lt;/code&gt;，与红色杯子中，杂质蓝色液体的体积&lt;code&gt;l*L/(L+l)&lt;/code&gt;相等，因此两个杯子里杂质一样多。&lt;/p&gt;

&lt;p&gt;好吧，我确实错了。但是，我错在哪了呢？&lt;/p&gt;

&lt;p&gt;再重新考虑一遍我的想法：&lt;/p&gt;

&lt;p&gt;从红的中取出一试管，倒入蓝的中，搅匀。这时候蓝色溶液里杂质的浓度为&lt;code&gt;a&lt;/code&gt;。——这个应该是没有问题的。红色的杂质浓度为&lt;code&gt;a=l/(L+l)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后再从这杯杂质浓度为&lt;code&gt;a&lt;/code&gt;的液体中取出一试管，倒入红的里。——依旧OK，&lt;code&gt;a&lt;/code&gt;的值没有变化。&lt;/p&gt;

&lt;p&gt;由于红的之前是纯净的，倒入杂质浓度为&lt;code&gt;a&lt;/code&gt;的液体后，相当于对这个液体做稀释，因此现在红色这杯子里的杂质浓度小于&lt;code&gt;a&lt;/code&gt;。——嗯……这个……坏了！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a&lt;/code&gt;的浓度是相对于蓝色液体而言的红色液体浓度，但是，当把这个试管内的液体倒入红色液体的杯子时，杂质的概念变了！对红色杯子而言，蓝色才是杂质，因此，这个试管里的杂质浓度实际上是&lt;code&gt;[1-l/(L+l)]&lt;/code&gt;，也就是&lt;code&gt;L/(L+l)&lt;/code&gt;！这样，实际被稀释的就是蓝色液体！而&lt;code&gt;L/(L+l)&lt;/code&gt;与&lt;code&gt;l/(L+l)&lt;/code&gt;明显是不等的！因此之后的推理就全部是错误的了……&lt;/p&gt;

&lt;p&gt;ok，想明白了，长出一口气……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>求3的余数</title>
      <link>http://air.googol.im/post/mod-3/</link>
      <pubDate>Fri, 04 Feb 2005 20:00:00 +0800</pubDate>
      
      <guid>http://air.googol.im/post/mod-3/</guid>
      <description>&lt;p&gt;北京华为的一道面试题。要求是只使用+-*和移位运算，且不能递减3求得余数。&lt;/p&gt;

&lt;p&gt;先在csdn上求，求得以下算法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int i, m, n, p, q;
int yushu[]={1, 2};
m = n;
while(m&amp;gt;3)
{
 i=0;  q=0;
 while(m)
 {
  i&amp;amp;=0x1;
  q+=(m&amp;amp;0x1)*yushu[i++];
  m&amp;gt;&amp;gt;=1;
 }
 m=q;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没看懂，倒是提示我可以用查表的方法，变成求4的余数。自己探求程序如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int mo[]={0,1,2,0};
int i, m;
m = n;
i = 4;
while (i&amp;gt;3)
{
 i = 0;
 while(m&amp;gt;0)
 {
  i += m &amp;amp; 3;
  m &amp;gt;&amp;gt;= 2;
 }
 m = i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;貌似比网上高人给的算法效率更高，可惜没去证实。&lt;/p&gt;

&lt;p&gt;晚上又想到更高效的算法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int mo[]={0,1,2,0};
int m;
while(m&amp;gt;3)
{
 m = (m&amp;gt;&amp;gt;2) + (m&amp;amp;3);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想来不会有更高效的做法了，于是开始这种算法的数学证明，如下：&lt;/p&gt;

&lt;p&gt;因为&lt;code&gt;4 mod 3=1&lt;/code&gt;，所以&lt;code&gt;4^k mod 3 = 1^k mod 3&lt;/code&gt;（此原理来源于小学数学奥校五年级分册= =|||），所以对任意数n，转化成4进制数后每位为n1 n2 n3 n4&amp;hellip;nm，有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(n1*4^(m-1)+n2*4^(m-2)+n3*4^(m-3)+n4*4^(m-4)+...+nm-1*4^1+nm*4^0) mod 3
=n1*4^(m-1) mod 3+n2*4^(m-2) mod 3+n3*4^(m-3) mod 3+n4*4^(m-4) mod 3+...+nm-1*4^1 mod 3+nm*4^0 mod 3
=n1*1^(m-1) mod 3+n2*1^(m-2) mod 3+n3*1^(m-3) mod 3+n4*1^(m-4) mod 3+...+nm-1*1^1 mod 3+nm*1^0 mod 3
=(n1+n2+n3+n4+...+nm-1+nm) mod 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此对数n每次取二进制最后两位（四进制的最后一位），并加入除去二进制最后两位的余数（相当于右移2位），如此反复，直到只剩最后两位，此两位二进制数与原数n同余于3。&lt;/p&gt;

&lt;p&gt;现在研究的是，求任意数的余数的高效算法是什么呢？&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>