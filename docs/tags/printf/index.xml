<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Printf on Air on G</title>
    <link>http://air.googol.im/tags/printf/index.xml</link>
    <description>Recent content in Printf on Air on G</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>除非另有声明，本网站采用&lt;a href=&#39;https://creativecommons.org/licenses/by-nd/3.0/cn/&#39;&gt;知识共享“署名-禁止演绎 3.0 中国大陆”许可协议&lt;/a&gt;授权。</copyright>
    <atom:link href="http://air.googol.im/tags/printf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>内核printf源代码分析</title>
      <link>http://air.googol.im/post/analysis-of-source-code-printf/</link>
      <pubDate>Mon, 18 Oct 2004 20:00:00 +0800</pubDate>
      
      <guid>http://air.googol.im/post/analysis-of-source-code-printf/</guid>
      <description>&lt;p&gt;对VC里printf的实现的分析。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在stdio.c里找到了printf的实现代码.首先看看对printf的定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int printf (const char *cntrl_string, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数cntrl_string是控制字符串,也就是平常我们写入%d,%f的地方.紧接着后面是一个变长参数.&lt;/p&gt;

&lt;p&gt;看看函数头部的定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  int pos = 0, cnt_printed_chars = 0, i;
  unsigned char* chptr;
  va_list ap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;马上晕!除了ap我们可以马上判断出来是用来读取变长参数的,i用于循环变量.其他变量都不知道是怎么回事.不要着急,我们边看代码边分析.代码的第一行必然是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;va_start (ap, cntrl_string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来初始化变长参数.&lt;/p&gt;

&lt;p&gt;接下来是一个while循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while (cntrl_string[pos]) {
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结束条件是cntrl_string[pos]为NULL,显然这个循环是用来遍历整个控制字符串的.自然pos就是当前遍历到的位置了.进入循环首先闯入视线的是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (cntrl_string[pos] == &#39;%&#39;) {
     pos++;
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开门见山,上来就当前字符是否办断是否%.一猜就知道如果成立pos++马上取出下一个字符在d,f,l等等之间进行判断.往下一看,果真不出所料:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;switch (cntrl_string[pos]) {
    case &#39;c&#39;:
...
    case &#39;s&#39;:
...
    case &#39;i&#39;:
...
    case &#39;d&#39;:
...
    case &#39;u&#39;:
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用上switch-case了. 快速浏览一下下面的代码.&lt;/p&gt;

&lt;p&gt;首先看看case &amp;lsquo;c&amp;rsquo;的部分&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;case &#39;c&#39;:
 putchar (va_arg (ap, unsigned char));
 cnt_printed_chars++;
 break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;%c表示仅仅输出一个字符.因此先通过va_arg进行参数的类型转换,之后用putchar[1]输出到屏幕上去.之后是cnt_printed_chars++,通过这句我们就可以判断出cnt_printed_chars使用来表示,已经被printf输出的字符个数的.&lt;/p&gt;

&lt;p&gt;再来看看 case &amp;rsquo;s&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;case &#39;s&#39;:
 chptr = va_arg (ap, unsigned char*);
 i = 0;
 while (chptr [i]) {
   cnt_printed_chars++;
   putchar (chptr [i++]);
 }
 break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和case &amp;lsquo;c&amp;rsquo;,同出一辙.cnt_printed_chars++放在了循环内,也证明了刚才提到的他的作用.另外我们也看到了cnptr是用来在处理字符串时的位置指针.到此为止,我们清楚的所有变量的用途,前途变得更加光明了.&lt;/p&gt;

&lt;p&gt;接下来:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// PartI
      case &#39;i&#39;:
      case &#39;d&#39;:
 cnt_printed_chars += printInt (va_arg (ap, int));
 break;
      case &#39;u&#39;:
 cnt_printed_chars += printUnsignedInt (va_arg (ap, unsigned int));
 break;
      case &#39;x&#39;:
 cnt_printed_chars += printHexa (va_arg (ap, unsigned int), &#39;x&#39;);
 break;
      case &#39;X&#39;:
 cnt_printed_chars += printHexa (va_arg (ap, unsigned int), &#39;X&#39;);
 break;
      case &#39;o&#39;:
 cnt_printed_chars += printOctal (va_arg (ap, unsigned int));
 break;
// Part II
 case &#39;p&#39;:
 putchar (&#39;0&#39;);
 putchar (&#39;x&#39;);
 cnt_printed_chars += 2; /* of &#39;0x&#39; */
 cnt_printed_chars += printHexa (va_arg (ap, unsigned int), &#39;x&#39;);
 break;
      case &#39;#&#39;:
 pos++;
 switch (cntrl_string[pos]) {
 case &#39;x&#39;:
   putchar (&#39;0&#39;);
   putchar (&#39;x&#39;);
   cnt_printed_chars += 2; /* of &#39;0x&#39; */
   cnt_printed_chars += printHexa (va_arg (ap, unsigned int), &#39;x&#39;);
   break;
 case &#39;X&#39;:
   putchar (&#39;0&#39;);
   putchar (&#39;X&#39;);
   cnt_printed_chars += 2; /* of &#39;0X&#39; */
   cnt_printed_chars += printHexa (va_arg (ap, unsigned int), &#39;X&#39;);
   break;
 case &#39;o&#39;:
   putchar (&#39;0&#39;);
   cnt_printed_chars++;
   cnt_printed_chars += printOctal (va_arg (ap, unsigned int));
   break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意观察一下,PartII的代码其实就是比PartI的代码多一个样式.在16进制数或八进制前加入0x或是o,等等.因此这里就只分析一下PartI咯.&lt;/p&gt;

&lt;p&gt;其实仔细看看PartI的个条case,也就是把参数分发到了更具体的函数用于显示,然后以返回值的形式返回输出个数.对于这些函数就不具体分析了.我们先来看看一些善后处理:&lt;/p&gt;

&lt;p&gt;先看case的default处理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;default:
 putchar ((unsigned char) cntrl_string[pos]);
 cnt_printed_chars++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是直接输出cntrl_string里%号后面的未知字符.应该是一种容错设计处理.&lt;/p&gt;

&lt;p&gt;再看看if (cntrl_string[pos] == &amp;lsquo;%&amp;rsquo;)的else部分&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;else {
      putchar ((unsigned char) cntrl_string[pos]);
      cnt_printed_chars++;
      pos++;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不是%开头的,那么直接输出这个字符.&lt;/p&gt;

&lt;p&gt;最后函数返回前&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  va_end (ap);
  return cnt_printed_chars;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;va_end处理变长参数的善后工作.并返回输出的字符个数.&lt;/p&gt;

&lt;p&gt;在最后我们有必要谈谈putChar函数以及基本输出的基础函数printChar,先来看看putChar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int putchar (int c) {
  switch ((unsigned char) c) {
  case &#39;\n&#39; :
    newLine ();
    break;
  case &#39;\r&#39; :
    carriageReturn ();
    break;
  case &#39;\f&#39; :
    clearScreen ();
    break;
  case &#39;\t&#39; :
    printChar (32); printChar (32); /* 32 = space */
    printChar (32); printChar (32);
    printChar (32); printChar (32);
    printChar (32); printChar (32);
    break;
  case &#39;\b&#39;:
    backspace ();
    break;
  case &#39;\a&#39;:
    beep ();
    break;
  default :
    printChar ((unsigned char) c);
  }
  return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通览一下,也是switch-case为主体的.主要是用来应对一些特殊字符,如\n,\r,&amp;hellip;.这里需要提一下,关于\t的理解.有些人认为\t就是8个space,有些人则认为,屏幕分为10大列(每个大列8个小列总共80列).一个\t就跳到下一个大列输出.也就是说不管你现在实在屏幕的第1,2,3,4,5,6,7位置输出字符,只要一个\t都在第8个位置开始输出. VS.NET中就是用的这种理解.因此如果按照这个理解的话,\t的实现可以这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int currentX = ((currentX % 10) + 1) * 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在currentX位置输出.&lt;/p&gt;

&lt;p&gt;接下来看printChar也就是输出部分最低层的操作咯&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void printChar (const byte ch) {
  *(word *)(VIDEO + y * 160 + x * 2) = ch | (fill_color &amp;lt;&amp;lt; 8);
  x++;
  if (x &amp;gt;= WIDTH)
    newLine ();
  setVideoCursor (y, x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里VIDEO表示显存地址也就是0xB8000.通过&lt;code&gt;y * 160 + x&lt;/code&gt;屏幕&lt;code&gt;(x,y)&lt;/code&gt;坐标在显存中的位置.这里需要知道,一个字符显示需要两个字节,一个是ASCII码,第二个是字符属性代码也就是颜色代码.因此才必须&lt;code&gt;y * 80 * 2 + x = y * 160 + x&lt;/code&gt;.那么&lt;code&gt;ch | (fill_color &amp;lt;&amp;lt; 8)&lt;/code&gt;也自然就是写入字符及属性代码用的了.每写一个字符光标位置加1,如果大于屏幕宽度WIDTH就换行.最后通过setVideoCursor设置新的光标位置.完成了整个printChar过程.&lt;/p&gt;

&lt;p&gt;到此,把printf从上到下说了一遍.不知道各位大家感觉如何,如果说得不清楚还大家多提意见.有说得不对的地方请大家多多指教.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>