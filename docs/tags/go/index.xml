<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Go on Air On G</title>
    <link>https://air.googol.im/tags/go/</link>
    <description>Recent content in Go on Air On G</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 20 Feb 2022 17:37:40 +0100</lastBuildDate>
    <atom:link href="https://air.googol.im/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 1.18新库netaddr里的intern.Value</title>
      <link>https://air.googol.im/posts/go-netaddr-value/</link>
      <pubDate>Sun, 20 Feb 2022 17:37:40 +0100</pubDate>
      <guid>https://air.googol.im/posts/go-netaddr-value/</guid>
      <description>&lt;p&gt;Go 1.18引入了新库&lt;code&gt;netaddr&lt;/code&gt;来表示IP地址及相关操作。其作者Brad Fitzpatrick专门写了篇&lt;a href=&#34;https://tailscale.com/blog/netaddr-new-ip-type-for-go/&#34;&gt;blog&lt;/a&gt;说明这个库的设计原则和最终实现。&lt;/p&gt;
&lt;p&gt;这个实现最主要的特性依赖&lt;a href=&#34;https://pkg.go.dev/go4.org/intern&#34;&gt;intern.Value&lt;/a&gt;这个库。这里记录一下我对这个库的一些研究和看法&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Go Swagger生成OpenAPI定义</title>
      <link>https://air.googol.im/posts/go-swagger-spec/</link>
      <pubDate>Sat, 04 Dec 2021 11:11:08 +0100</pubDate>
      <guid>https://air.googol.im/posts/go-swagger-spec/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://swagger.io/specification/&#34;&gt;OpenAPI&lt;/a&gt;（原名Swagger）是目前比较流行的定义HTTP API的协议。但是OpenAPI的定义文件是方便机器处理的格式，不易编写和阅读。这里介绍一种使用&lt;a href=&#34;https://goswagger.io/&#34;&gt;go-swagger&lt;/a&gt;，根据Go代码生成OpenAPI定义文件的方法。该方法只使用Go代码来定义API，不强求Server或者Client也使用Go。&lt;/p&gt;
&lt;p&gt;目前&lt;code&gt;go-swagger&lt;/code&gt;只能生成OpenAPI 2.0格式的定义。这个也是现在广泛使用的格式。&lt;code&gt;go-swagger&lt;/code&gt;未来会支持OpenAPI 3.0。&lt;/p&gt;
&lt;p&gt;本文假设已经熟悉Go语法，只对&lt;code&gt;go-swagger&lt;/code&gt;的扩展部分进行详细解释。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一个Go开发者的Rust体验</title>
      <link>https://air.googol.im/posts/rust-view-from-a-gopher/</link>
      <pubDate>Sat, 21 Jul 2018 11:10:00 +0200</pubDate>
      <guid>https://air.googol.im/posts/rust-view-from-a-gopher/</guid>
      <description>&lt;p&gt;一直很关注Rust这门语言的发展，不过没有实际使用过。最近Rust准备以2018 Rust的名义发布可以用作生产环境的稳定版本，又赶上有兴趣写点东西，所以把一个基础模块同时用Rust和Go实现了一下。本文就是这次实现的一些结果。&lt;/p&gt;
&lt;p&gt;我自己有很长的Go使用经历，所以本文对Go的看法会相对比较准确。Rust虽然关注了很长时间，但代码基本上是最近一个星期左右的成果，可能看法有偏颇。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我对Go 2类型系统的期望</title>
      <link>https://air.googol.im/posts/what-i-want-in-go2-type-system/</link>
      <pubDate>Wed, 10 Jan 2018 15:24:03 +0800</pubDate>
      <guid>https://air.googol.im/posts/what-i-want-in-go2-type-system/</guid>
      <description>&lt;p&gt;我应该算是第一批使用Go做实际开发的程序员，也写过一些比较深入的项目（比如go-socket.io)。我想总结一下Go里关于类型系统好用的部分以及不好用的部分。这些特性会集中在语言层面，而且基本上是Go 1基本不可能有改动的特性。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
